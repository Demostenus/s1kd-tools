.\" Automatically generated by Pandoc 1.19.2.1
.\"
.TH "s1kd\-instance" "1" "2018\-07\-25" "" "s1kd\-tools"
.hy
.SH NAME
.PP
s1kd\-instance \- Create S1000D data/pub module instances
.SH SYNOPSIS
.IP
.nf
\f[C]
s1kd\-instance\ [options]\ [<object>...]
\f[]
.fi
.SH DESCRIPTION
.PP
The \f[I]s1kd\-instance\f[] tool produces an "instance" of an S1000D
CSDB object, derived from a "master" (or "source") object.
The tool supports multiple methods of instantiating an object:
.IP \[bu] 2
Filtering on user\-supplied applicability definitions, so that
non\-applicable elements and (optionally) unused applicability
annotations are removed in the instance.
The definitions can be supplied directly or read from a PCT (Product
Cross\-reference Table).
.IP \[bu] 2
Filtering on skill levels and security classifications.
.IP \[bu] 2
Using a CIR (Common Information Repository) to produce a standalone
instance from a CIR\-dependent master.
.IP \[bu] 2
Changing various pieces of metadata in the instance.
.PP
Any combination of these methods can be used when producing an instance.
.SH OPTIONS
.TP
.B \-A
Simplify applicability annotations and remove unused ones.
.RS
.RE
.TP
.B \-a
Remove unused applicability annotations.
.RS
.RE
.TP
.B \-C <comment>
Add an XML comment to an instance.
Useful as another way of identifying an object as an instance aside from
the source address or extended code, or giving additional information
about a particular instance.
By default, the comment is inserted at the top of the document, but this
can be customized with the \-X option.
.RS
.RE
.TP
.B \-c <dmc>
Specify a new data module code (DMC) or publication module code (PMC)
for the instance.
.RS
.RE
.TP
.B \-E
Remove the extension from an instance produced from an already extended
object.
.RS
.RE
.TP
.B \-e <ext>
Specify an extension on the data module code (DME) or publication module
code (PME) for the instance.
.RS
.RE
.TP
.B \-F
After filtering, "alts" elements containing only one child element will
be "flattened" by replacing them with the applicable child element.
Alts elements with multiple child elements are left untouched.
.RS
.RE
.TP
.B \-f
Overwrite existing file with same name as the filename generated
automatically with \-O, if it exists.
.RS
.RE
.TP
.B \-G <CODE>/<NAME>
Similar to the \-g option, but instead of the default enterprise code
and name, use the values <CODE> and <NAME>, which are separated by a
slash (/).
To only include a code, specify <CODE> with no slash.
To only include a name, specify <NAME> prefixed by a slash.
.RS
.RE
.TP
.B \-g
Set the originator of the instance.
When this option is specified, the code "\f[C]S1KDI\f[]" and the name
"\f[C]s1kd\-instance\ tool\f[]" are used by default to identify that the
instance was produced by this tool.
A different code and name can be specified with the \-G option.
.RS
.RE
.TP
.B \-I <date>
Set the issue date of the instance.
By default, the issue date is taken from the source.
.RS
.RE
.TP
.B \-i <infoName>
Give the data module instance a different infoName.
.RS
.RE
.TP
.B \-K <levels>
Filter the object on the specified skill levels.
Elements which are marked with skill levels not contained in the string
<levels> are removed in the resulting instance.
.RS
.RE
.TP
.B \-k <level>
Set the skill level of the instance.
.RS
.RE
.TP
.B \-L
Source is a list of object filenames to create instances of, rather than
an object itself.
.RS
.RE
.TP
.B \-l <lang>
Set the language and country of the instance.
For example, to create an instance for US English, lang would be
"en\-US".
.RS
.RE
.TP
.B \-m <remarks>
Set the remarks for the instance.
.RS
.RE
.TP
.B \-N
Omit issue/inwork numbers from automatically generated filenames.
.RS
.RE
.TP
.B \-n <iss>
Set the issue and inwork numbers of the instance.
By default, the issue and inwork number are taken from the source.
.RS
.RE
.TP
.B \-O <dir>
Output instance(s) in dir, automatically naming them based on:
.RS
.IP \[bu] 2
the extension specified with \-e
.IP \[bu] 2
the code specified with \-c
.IP \[bu] 2
The issue info specified with \-n
.IP \[bu] 2
the language and country specified with \-L
.PP
If any of the above are not specified, the information is copied from
the source object.
.RE
.TP
.B \-o <file>
Output instance to file instead of stdout.
.RS
.RE
.TP
.B \-P <PCT>
PCT file to read product definitions from (\-p).
If a product is specified but no PCT is given, the tool will attempt to
use the ACT reference of each source data module to find the ACT and PCT
data modules in the current directory.
.RS
.RE
.TP
.B \-p <product>
The ID or primary key of a product in the the specified PCT data module
(\-P) or the PCT data module referenced by the source data module.
A primary key is given in the same form as the \-s option and should
match a unique assign of a product instance, e.g.,
"\f[C]serialno:prodattr=12345\f[]"
.RS
.RE
.TP
.B \-R <CIR> ...
Use a CIR to resolve external dependencies in the master object, making
the instance object standalone.
Additional CIRs can be used by specifying the \-R option multiple times.
.RS
.PP
The following CIRs have some built\-in support:
.IP \[bu] 2
Access points
.IP \[bu] 2
Applicability
.IP \[bu] 2
Cautions
.IP \[bu] 2
Circuit breakers
.IP \[bu] 2
Controls/indicators
.IP \[bu] 2
Enterprises
.IP \[bu] 2
Functional items
.IP \[bu] 2
Illustrated parts data
.IP \[bu] 2
Parts
.IP \[bu] 2
Supplies
.IP \[bu] 2
Tools
.IP \[bu] 2
Warnings
.IP \[bu] 2
Zones
.PP
The methods of resolving the dependencies for a CIR can be changed by
specifying a custom XSLT script with the \-r option.
The built\-in XSLT used for the above CIR data modules can be dumped
with the \-x option.
.RE
.TP
.B \-r <XSL>
Use a custom XSLT script to resolve CIR dependencies for the last
specified CIR.
.RS
.RE
.TP
.B \-S
Do not include <sourceDmIdent>/<sourcePmIdent>/<repositorySourceDmIdent>
in the instance.
.RS
.RE
.TP
.B \-s <applic>
An applicability definition in the form of
"\f[C]<ident>:<type>=<value>\f[]".
Any number of values can be defined by specifying this option multiple
times.
.RS
.RE
.TP
.B \-t <techName>
Give the instance a different techName/pmTitle.
.RS
.RE
.TP
.B \-U <classes>
Filter the object on the specified security classes.
Elements marked with security classes not contained in the string
<classes> are removed in the resulting instance.
.RS
.RE
.TP
.B \-u <sec>
Set the security classification of the instance.
An instance may have a lower security classification than the source if
classified information is removed for a particular customer.
.RS
.RE
.TP
.B \-v
When \-O is used, print the automatically generated file name of the
instance.
.RS
.RE
.TP
.B \-w
Check the applicability, skill level, and security classification of the
whole object against the user\-defined applicability, skill levels, and
security classifications.
If the whole object is not applicable, then no instance is created.
.RS
.RE
.TP
.B \-X <path>
The XPath expression indicating where the comment specified with \-C
will be inserted.
This should be the path to an element where the comment will be inserted
as the first child node.
By default, this is the top of the document.
.RS
.RE
.TP
.B \-x <CIR>
Dumps the built\-in XSLT used to resolve dependencies for <CIR> CIR type
to stdout.
This can be used as a starting point for a custom XSLT script to be
specified with the \-r option.
.RS
.PP
The following types currently have built\-in XSLT and can therefore be
used as values for <CIR>:
.IP \[bu] 2
accessPointRepository
.IP \[bu] 2
applicRepository
.IP \[bu] 2
cautionRepository
.IP \[bu] 2
circuitBreakerRepository
.IP \[bu] 2
controlIndicatorRepository
.IP \[bu] 2
enterpriseRepository
.IP \[bu] 2
functionalItemRepository
.IP \[bu] 2
illustratedPartsCatalog
.IP \[bu] 2
partRepository
.IP \[bu] 2
supplyRepository
.IP \[bu] 2
toolRepository
.IP \[bu] 2
warningRepository
.IP \[bu] 2
zoneRepository
.RE
.TP
.B \-Y <text>
Set the applicability for the whole object using the user\-defined
applicability values, using text as the new display text.
.RS
.RE
.TP
.B \-y
Set the applicability for the whole data object using the user\-defined
applicability values, with no display text.
.RS
.RE
.TP
.B \-\-version
Show version information.
.RS
.RE
.TP
.B <object>...
Source CSDB objects to instantiate.
.RS
.RE
.SS Identifying the source of an instance
.PP
The resulting data module instances will contain the element
<sourceDmIdent>, which will contain the identification elements of the
source data modules used to instantiate them.
Publication module instances will contain the element <sourcePmIdent>
instead.
.PP
Additionally, the data module instance will contain an element
<repositorySourceDmIdent> for each CIR specified with the \-R option.
.PP
If the \-S option is used, neither the <sourceDmIdent>/<sourcePmIdent>
elements or <repositorySourceDmIdent> elements are added.
This can be useful when this tool is not used to make an "instance" per
se, but more generally to make a module based on an existing module.
.SS Instance module code (\-c) vs extension (\-e)
.PP
When creating a data module or publication module instance, the instance
should have the same data module/publication module code as the master,
with an added extension code, the DME/PME.
However, in cases where a vendor does not support this extension or
possibly when this tool is used to create "instances" which will from
that point on be maintained as normal standalone data
modules/publication modules, it may be desirable to change the data
module/publication module code instead.
These two options can be used together as well to give an instance a new
DMC/PMC as well an extension.
.SS Removing/simplifying applicability annotations (\-a vs \-A)
.PP
By default, filtering on applicability will remove invalid elements from
the resulting instance.
In some cases, though, it may be desirable to remove redundant
applicability annotations on valid elements.
The \-a and \-A options provide two methods of doing this.
.PP
The \-a option will remove applicability annotations (applicRefId) from
elements which are deemed to be unambiguously valid (their validity does
not rely on applicability values left undefined by the user).
Unused occurrences of the corresponding applic elements are removed as
well.
.PP
The \-A option will do the same as the \-a option, but will also attempt
to simplify unused parts of applicability annotations.
It simplifies an annotation by removing <assert> elements determined to
be either unambiguously valid or invalid given the user\-defined values,
and removing unneeded <evaluate> elements when they contain only one
remaining <assert>.
.PP
For example, given the following input:
.IP
.nf
\f[C]
<referencedApplicGroup>
<applic\ id="app\-0001">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
</applic>
<applic\ id="app\-0002">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="B"/>
</applic>
<applic\ id="app\-0003">
<evaluate\ andOr="or">
<evaluate\ andOr="and">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="normal"/>
</evaluate>
<evaluate\ andOr"and">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="B"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="icy"/>
</evaluate>
</evaluate>
</applic>
</referencedApplicGroup>
<!\-\-\ snip\ \-\->
<para\ applicRefId="app\-0001">This\ applies\ to\ version\ A.</para>
<para\ applicRefId="app\-0002">This\ applies\ to\ version\ B.</para>
<para\ applicRefId="app\-0003">
This\ applies\ to\ version\ A\ if\ the\ weather\ is\ normal,\ or\ version\ B\ if
the\ weather\ is\ icy.
</para>
\f[]
.fi
.PP
If this data is filtered for version A, without specifying a value for
the weather, and neither the \-a or \-A option is used, the following
will be the result:
.IP
.nf
\f[C]
<referencedApplicGroup>
<applic\ id="app\-0001">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
</applic>
<applic\ id="app\-0002">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="B"/>
</applic>
<applic\ id="app\-0003">
<evaluate\ andOr="or">
<evaluate\ andOr="and">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="normal"/>
</evaluate>
<evaluate\ andOr"and">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="B"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="icy"/>
</evaluate>
</evaluate>
</applic>
</referencedApplicGroup>
<!\-\-\ snip\ \-\->
<para\ applicRefId="app\-0001">This\ applies\ to\ version\ A.</para>
<para\ applicRefId="app\-0003">
This\ applies\ to\ version\ A\ if\ the\ weather\ is\ normal,\ or\ version\ B\ if
the\ weather\ is\ icy.
</para>
\f[]
.fi
.PP
The second paragraph is removed, because it only applies to version B.
.PP
If the \-a option is used, the following would be the result:
.IP
.nf
\f[C]
<referencedApplicGroup>
<applic\ id="app\-0003">
<evaluate\ andOr="or">
<evaluate\ andOr="and">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="normal"/>
</evaluate>
<evaluate\ andOr"and">
<assert
applicPropertyIdent="version"
applicPropertyType="prodattr"
applicPropertyValues="B"/>
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="icy"/>
</evaluate>
</evaluate>
</applic>
</referencedApplicGroup>
<!\-\-\ snip\ \-\->
<para>This\ applies\ to\ version\ A.</para>
<para\ applicRefId="app\-0003">
This\ applies\ to\ version\ A\ if\ the\ weather\ is\ normal,\ or\ version\ B\ if
the\ weather\ is\ icy.
</para>
\f[]
.fi
.PP
The applicability annotation reference for the first paragraph is
removed because, given that the version must is A, it must be true.
The corresponding applicability annotations, which are no longer
referenced, are also removed.
The applicability on the third paragraph remains, however, because it is
only true if the version is A \f[I]and\f[] the weather is normal, and no
value has been given for the weather.
.PP
If the \-A option is used, the following would be the result:
.IP
.nf
\f[C]
<referencedApplicGroup>
<applic\ id="app\-0003">
<assert
applicPropertyIdent="weather"
applicPropertyType="condition"
applicPropertyValues="normal"/>
</applic>
</referencedApplicGroup>
<!\-\-\ snip\ \-\->
<para>This\ applies\ to\ version\ A.</para>
<para\ applicRefId="app\-0003">
This\ applies\ to\ version\ A\ if\ the\ weather\ is\ normal,\ or\ version\ B\ if
the\ weather\ is\ icy.
</para>
\f[]
.fi
.PP
The annotation is now simplified to remove resolved assertions.
Because the version must be A, any assertions restating this can be
removed as redundant, and any portions of the annotation in which the
version is \f[I]not\f[] A can be removed as invalid.
This leaves only the assertion about the weather.
.RS
.PP
\f[B]Note\f[]
.PP
The \-A option may change the \f[I]meaning\f[] of certain applicability
annotation without changing the \f[I]display text\f[].
Display text is always left untouched, so using this option may cause
display text to be technically incorrect.
This option is best used when display text will be automatically
generated after filtering, such as with the s1kd\-aspp tool.
.RE
.SS Filtering for multiple values of a single property
.PP
Though not usually the case, it is possible to create an instance which
is filtered on multiple values of the same applicabilty property.
Given the following:
.IP
.nf
\f[C]
<referencedApplicGroup>
<applic\ id="apA">
<assert\ applicPropertyIdent="attr"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
</applic>
<applic\ id="apB">
<assert\ applicPropertyIdent="attr"
applicPropertyType="prodattr"
applicPropertyValues="B"/>
</applic>
<applic\ id="apC">
<assert\ applicPropertyIdent="attr"
applicPropertyType="prodattr"
applicPropertyValues="C"/>
</applic>
</referencedApplicGroup>
<!\-\-\ ...\ \-\->
<para\ applicRefId="apA">Applies\ to\ A</para>
<para\ applicRefId="apB">Applies\ to\ B</para>
<para\ applicRefId="apC">Applies\ to\ C</para>
\f[]
.fi
.PP
filtering can be applied such that the instance will be applicable to
both A and C, but not B.
This is done by specifying a property multiple times in the
applicability definition arguments.
For example:
.IP
.nf
\f[C]
$\ s1kd\-instance\ \-A\ \-Y\ "A\ or\ C"\ \-s\ attr:prodattr=A\ \-s\ attr:prodattr=C\ ...
\f[]
.fi
.PP
This would produce the following in the instance:
.IP
.nf
\f[C]
<dmStatus>
<!\-\-\ ...\ \-\->
<applic>
<displayText>
<simplePara>A\ or\ C</simplePara>
</displayText>
<evaluate\ andOr="or">
<assert\ applicPropertyIdent="attr"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
<assert\ applicPropertyIdent="attr"
applicPropertyType="prodattr"
applicPropertyValues="C"/>
</evaluate>
</applic>
<!\-\-\ ...\ \->
</dmStatus>
<!\-\-\ ...\ \-\->
<referencedApplicGroup>
<applic\ id="apA">
<assert\ applicPropertyIdent="attr"
applicPropertyType="prodattr"
applicPropertyValues="A"/>
</applic>
<applic\ id="apC">
<assert\ applicPropertyIdent="attr"
applicPropertyType="prodattr"
applicPropertyValues="C"/>
</applic>
</referencedApplicGroup>
<!\-\-\ ...\ \-\->
<para\ applicRefId="apA">Applies\ to\ A</para>
<para\ applicRefId="apC">Applies\ to\ C</para>
\f[]
.fi
.SS Resolving CIR dependencies with a custom XSLT script (\-r)
.PP
A CIR contains more information about an item than can be captured in a
data module\[aq]s reference to it.
If this additional information is required, there are two methods to
include it:
.IP \[bu] 2
Distribute the CIR with the data module so the extra information can be
linked to
.IP \[bu] 2
"Flatten" the information to fit in the data module\[aq]s schema.
.PP
A custom XSLT script can be supplied with the \-r option, which is then
used to resolve the CIR dependencies of the last CIR specified with \-R.
For example:
.IP
.nf
\f[C]
<xsl:stylesheet
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
version="1.0">
<xsl:template\ match="functionalItemRef">
<xsl:variable\ name="fin"\ select"\@functionalItemNumber"/>
<xsl:variable\ name="spec"\ select="$cir//functionalItemSpec[
functionalItemIdent/\@functionalItemNumber\ =\ $fin]"/>
<xsl:value\-of\ select="$spec/name"/>
</xsl:template>
</xsl:stylesheet>
\f[]
.fi
.PP
This script would resolve a \f[C]functionalItemRef\f[] by "flattening"
it to the value of the \f[C]name\f[] element obtained from the CIR.
.PP
The example CIR would contain a specification like:
.IP
.nf
\f[C]
<functionalItemSpec>
<functionalItemIdent\ functionalItemNumber="ABC"
functionalItemType="fit01"/>
<name>Hydraulic\ pump</name>
<functionalItemAlts>
<functionalItem/>
</functionalItemAlts>
</functionalItemSpec>
\f[]
.fi
.PP
The source data module would contain a reference:
.IP
.nf
\f[C]
<para>
The
<functionalItemRef\ functionalItemNumber="ABC"/>
is\ an\ item\ in\ the\ system.
</para>
\f[]
.fi
.PP
The command would resemble:
.IP
.nf
\f[C]
$\ s1kd\-instance\ \-R\ <CIR>\ \-r\ <custom\ XSLT>\ <src>
\f[]
.fi
.PP
And the resulting XML would be:
.IP
.nf
\f[C]
<para>The\ Hydraulic\ pump\ is\ an\ item\ in\ the\ system.</para>
\f[]
.fi
.PP
The source data module and CIR are combined in to a single XML document
which is used as the input to the XSLT script.
The root element \f[C]mux\f[] contains two \f[C]dmodule\f[] elements.
The first is the source data module, and the second is the CIR data
module specified with the corresponding \-R option.
The CIR data module is first filtered on the defined applicability.
.PP
An "identity" template is automatically inserted in to the custom XSLT
script, equivalent to the following:
.IP
.nf
\f[C]
<xsl:template\ match="\@*|node()">
<xsl:copy>
<xsl:apply\-templates\ select="\@*|node()"/>
</xsl:copy>
</xsl:template>
\f[]
.fi
.PP
This means any elements or attributes which are not matched with a more
specific template in the custom XSLT script are automatically copied.
.PP
The set of built\-in XSLT scripts used to resolve dependencies can be
dumped using the \-x option.
.SH EXAMPLES
.PP
Filtering a data module on specified applicability and writing to
stdout:
.IP
.nf
\f[C]
$\ s1kd\-instance\ \-s\ version:prodattr=A\ <DM>
\f[]
.fi
.PP
Filtering a data module on a specified product instance and writing to
stdout:
.IP
.nf
\f[C]
$\ s1kd\-instance\ \-P\ <PCT>\ \-p\ versionA\ <DM>
\f[]
.fi
.PP
Filtering a data module on specified skill levels and writing to stdout:
.IP
.nf
\f[C]
$\ s1kd\-instance\ \-k\ sk01/sk02\ <DMs>
\f[]
.fi
.PP
Filtering data modules for a particular customer and outputting with
extended identification:
.IP
.nf
\f[C]
$\ s1kd\-instance\ \-s\ version:prodattr=A\ \-e\ 12345\-54321\ \-O\ .\ <DMs>
\f[]
.fi
.PP
Writing out a data module from stdin to a directory with automatic
naming:
.IP
.nf
\f[C]
$\ s1kd\-transform\ \-s\ <xsl>\ <DM>\ |\ s1kd\-instance\ \-O\ <dir>
\f[]
.fi
.SH AUTHORS
khzae.net.
